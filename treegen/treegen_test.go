/*******************************************************************************
 * Copyright (c) 2025 Genome Research Ltd.
 *
 * Author: Michael Woolnough <mw31@sanger.ac.uk>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

package treegen_test

import (
	"bytes"
	"io"
	"maps"
	"slices"
	"testing"

	. "github.com/smartystreets/goconvey/convey"
	"github.com/wtsi-hgi/backup-plans/internal/directories"
	"github.com/wtsi-hgi/backup-plans/treegen"
	"github.com/wtsi-hgi/wrstat-ui/stats"
	"github.com/wtsi-hgi/wrstat-ui/summary"
	"vimagination.zapto.org/byteio"
	"vimagination.zapto.org/tree"
)

func TestTimeTree(t *testing.T) {
	Convey("With a summarised time tree", t, func() {
		f := directories.NewRoot("/", 12345)

		f.AddDirectory("opt").SetMeta(99, 98, 1).AddDirectory("userDir").SetMeta(1, 1, 98765)
		directories.AddFile(&f.Directory, "opt/userDir/file1.txt", 1, 1, 9, 98766)
		directories.AddFile(&f.Directory, "opt/userDir/file2.txt", 1, 2, 8, 98767)
		directories.AddFile(&f.Directory, "opt/subDir/subsubDir/file3.txt", 1, 2, 7, 98000)

		f.AddDirectory("opt").AddDirectory("other").SetMeta(2, 1, 12349)
		directories.AddFile(&f.Directory, "opt/other/someDir/someFile", 2, 1, 6, 12346)
		directories.AddFile(&f.Directory, "opt/other/someDir/someFile", 2, 1, 5, 12346)

		p := stats.NewStatsParser(f.AsReader())
		s := summary.NewSummariser(p)

		var treeDB bytes.Buffer

		s.AddDirectoryOperation(treegen.NewTree(&treeDB))

		So(s.Summarise(), ShouldBeNil)

		tr, err := tree.OpenMem(treeDB.Bytes())
		So(err, ShouldBeNil)

		tr, err = tr.Child("/")
		So(err, ShouldBeNil)

		Convey("You can read a root summary", func() {
			r := bytes.NewReader(tr.Data())

			uid, gid, userSummary, groupSummary := readSummary(r)
			So(uid, ShouldEqual, 0)
			So(gid, ShouldEqual, 0)
			So(userSummary, ShouldResemble, []treegen.IDData{
				{1, &treegen.Meta{MTime: 98767, Files: 3, Bytes: 24}},
				{2, &treegen.Meta{MTime: 12346, Files: 1, Bytes: 5}},
			})
			So(groupSummary, ShouldResemble, []treegen.IDData{
				{1, &treegen.Meta{MTime: 98766, Files: 2, Bytes: 14}},
				{2, &treegen.Meta{MTime: 98767, Files: 2, Bytes: 15}},
			})

			So(slices.Sorted(maps.Keys(maps.Collect(tr.Children()))), ShouldResemble, []string{
				"opt/",
			})
		})

		Convey("You can read a subdirectory summary", func() {
			tr, err = tr.Child("opt/")
			So(err, ShouldBeNil)

			r := bytes.NewReader(tr.Data())

			uid, gid, userSummary, groupSummary := readSummary(r)
			So(uid, ShouldEqual, 99)
			So(gid, ShouldEqual, 98)
			So(userSummary, ShouldResemble, []treegen.IDData{
				{1, &treegen.Meta{MTime: 98767, Files: 3, Bytes: 24}},
				{2, &treegen.Meta{MTime: 12346, Files: 1, Bytes: 5}},
			})
			So(groupSummary, ShouldResemble, []treegen.IDData{
				{1, &treegen.Meta{MTime: 98766, Files: 2, Bytes: 14}},
				{2, &treegen.Meta{MTime: 98767, Files: 2, Bytes: 15}},
			})

			So(slices.Sorted(maps.Keys(maps.Collect(tr.Children()))), ShouldResemble, []string{
				"other/", "subDir/", "userDir/",
			})
		})

		Convey("You can read the ownership and mtime for a file", func() {
			tr, err = tr.Child("opt/")
			So(err, ShouldBeNil)

			tr, err = tr.Child("userDir/")
			So(err, ShouldBeNil)

			tr, err = tr.Child("file1.txt")
			So(err, ShouldBeNil)

			r := bytes.NewReader(tr.Data())

			rootUID, rootGID, rootMtime, rootBytes := readMeta(r)
			So(rootUID, ShouldEqual, 1)
			So(rootGID, ShouldEqual, 1)
			So(rootMtime, ShouldEqual, 98766)
			So(rootBytes, ShouldEqual, 9)
		})

		Convey("The generated bytes should match a direct conversion to a tree", func() {
			var buf bytes.Buffer

			So(tree.Serialise(&buf, f), ShouldBeNil)
			So(treeDB.Bytes(), ShouldResemble, buf.Bytes())
		})
	})
}

func readMeta(r io.Reader) (uint32, uint32, int64, uint64) {
	lr := byteio.StickyLittleEndianReader{Reader: r}

	return uint32(lr.ReadUintX()), uint32(lr.ReadUintX()), int64(lr.ReadUintX()), lr.ReadUintX()
}

func readSummary(r io.Reader) (uint32, uint32, []treegen.IDData, []treegen.IDData) {
	lr := byteio.StickyLittleEndianReader{Reader: r}

	uid := lr.ReadUintX()
	gid := lr.ReadUintX()

	lr.ReadUint8()
	lr.ReadUint8()

	return uint32(uid), uint32(gid), readArray(&lr), readArray(&lr)
}

func readArray(lr *byteio.StickyLittleEndianReader) []treegen.IDData {
	idts := make([]treegen.IDData, lr.ReadUintX())

	for n := range idts {
		idts[n].ID = uint32(lr.ReadUintX())
		idts[n].Meta = new(treegen.Meta)
		idts[n].MTime = lr.ReadUintX()
		idts[n].Files = lr.ReadUintX()
		idts[n].Bytes = lr.ReadUintX()
	}

	return idts
}
